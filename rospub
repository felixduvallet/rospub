#!/usr/bin/env python

"""

Interactive terminal for publishing messages on a given ROS topic.

Usage:
    rospub <topic> <message_type>
    e.g.
    rospub /language std_msgs.msg.String

Interactively waits for input on the terminal, creates a ROS message of
the desired type, and publishes it to the given topic. CTRL+D quits.

Author: Felix Duvallet <felix.duvallet@epfl.ch>

"""

import argparse
import sys
import rospy

import std_msgs



def run(topic, message_type_str):
    # Get the actual message type.


    pub = rospy.Publisher(topic, message_type, queue_size=1)

    rospy.loginfo('Publishing message type {} on topic {}.'.
                  format(message_type, topic))
    rospy.loginfo('Use Ctrl+D to quit, NOTE that Ctrl+C breaks everything.')

    done = False
    while not done:
        try:
            term_input = raw_input('>>> ')
        except KeyboardInterrupt:
            print('Keyboard interrupt')
            continue
        except EOFError:  # CTRL+D = quit
            done = True
            break

        # Prevent empty messages from going out.
        if not term_input:
            continue

        msg = message_type(term_input)
        rospy.loginfo('Published message: {}'.format(msg))
        pub.publish(msg)
        pass
    rospy.loginfo('Finished')


def make_message(message_type_str, content):
    """Creates a ROS message with the appropriate content.

    Both the content and message_type are strings (the message content is returned
    from raw_input).

    Converts the message type string into an actual message class, and then
    creates a ROS message with the content. Some voodoo happens to make sure the
    message data is correct (Int32 have ints, String have astrings, etc...).

    :param message_type_str String representation of the message type.

    :param content The content of the message as a string.

    """
    # Get the actual message type.
    message_t = eval(message_type_str)

    msg = None
    try:
        msg = message_t(eval(content))
        return msg
    except SyntaxError:
        # For example if we get a string as input.
        pass

    msg = message_t(content)
    return msg


def options(args):
    parser = argparse.ArgumentParser(
        description=('Publish messages directly from the terminal to a topic.\n'
                     'Usage: rospub <topic> <message type>'),
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('topic',  metavar='topic',
                        help='ROS topic.')
    parser.add_argument('message',  metavar='message',
                        help='ROS message type (e.g., std_msgs.msg.String).')
    parser.print_help()

    arguments = parser.parse_args(args)
    return arguments.topic, arguments.message


if __name__ == '__main__':
    args = sys.argv[1:]  # argv[0] is program name.
    (ros_topic, message_type_str) = options(args)
    rospy.init_node('rospub', anonymous=True)
    run(ros_topic, message_type_str)
